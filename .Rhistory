install.packages(“primes”)
# Part A: Create a matrix P whose entries are all prime numbers below 30.
generate_primes(max = 30)
# Part A: Create a matrix P whose entries are all prime numbers below 30.
#generate_primes(max = 30)
cells <- c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
P <- matrix(cells, nrow=5, ncol=2)
View(P)
# Part B: Extract the second and third row out of `P`.
P[ c(2,3), ]
View(P)
# Part C: Extract the entry in the fourth row and first column of `P`.
P[4,1]
# Part D: Generate the transpose of the matrix using the function `t()`.
#         What is the new dimension of this matrix?
t(P)
# Part D: Generate the transpose of the matrix using the function `t()`.
#         What is the new dimension of this matrix?
T <- t(P)
dim(T)
dim(P)
Girth = c(8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0)
Height = c(70, 65, 63, 72, 81, 83, 66)
Volume = c(10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6)
my.trees = data.frame(Girth, Height, Volume)
View(my.trees)
# Part 2: Extract the fifth observational unit.
my.trees[5,]
# Part 3: Extract the `Girth` column referring to it by name.
my.trees["Girth"]
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[c(1:(length(my.trees)-1)),]
length(my.trees)
nrow(my.trees)
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[c(1:(nrow(my.trees)-1)),]
# Part A: Check the structure of the`iris` data.
str(iris)
# Part C: Which variables are `numeric` type?
df[is.numeric(df)]
# Part C: Which variables are `numeric` type?
is.numeric(df)
# Part C: Which variables are `numeric` type?
is.numeric(iris)
# Part C: Which variables are `numeric` type?
typeof(iris)
# Part C: Which variables are `numeric` type?
is.numeric(iris[:])
# Part C: Which variables are `numeric` type?
is.numeric(iris[ , ])
# Part C: Which variables are `numeric` type?
is.numeric(iris[c(1:5), ])
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[1:(nrow(my.trees)-1),]
# Part C: Which variables are `numeric` type?
is.numeric(iris[1:5, ])
# Part A: Check the structure of the`iris` data.
str(iris)
# Part C: Which variables are `numeric` type?
is.numeric(names(iris))
names(iris)
# Part C: Which variables are `numeric` type?
is.numeric(iris$names(iris))
# Part C: Which variables are `numeric` type?
is.numeric(iris[, 1])
# Part C: Which variables are `numeric` type?
is.numeric(iris[1:5, 1])
is.numeric?
# Part C: Which variables are `numeric` type?
is.numeric(iris[1, ])
# Part C: Which variables are `numeric` type?
is.numeric(iris$Sepal.Length)
# Part A: Check the structure of the`iris` data.
str(iris)
# Part D: Display the first 4 rows of the data.
iris[1:4,]
str(my.trees)
# Part A: Read Titanic data directly from the web: <https://goo.gl/NHb1Pg>
titanic.data1 <- read.csv("https://goo.gl/NHb1Pg", header = TRUE)
d
# Part B: Read this data by saving it first into your working directory.
#         Check your working directory using `getwd()` or change its location using the steps covered in the lesson.
wd <- getwd()
titanic.data2 <- read.csv(paste(wd,"/Titanic_Data.csv"), header = TRUE)
titanic.data2 <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/Titanic_Data.csv", header = TRUE)
# Part C: How many passengers and what variables are in the data set?
str(titanic.data1)
# Part D: Display the first 5 rows of the data.
titanic.data1[1:5, ]
titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes"]
titanic.data1[titanic.data1$class != "1st class"]
titanic.data1[titanic.data1$class != "1st class", ]
titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes", ]
surv <- titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes", ]
titanic.data1[titanic.data1$class == "1st class", ]
first <- titanic.data1[titanic.data1$class == "1st class", ]
first <- titanic.data1[titanic.data1$class == "1st class" & titanic.data1$survived == "yes", ]
first <- titanic.data1[titanic.data1$class == "1st class", ]
firstSurv <- titanic.data1[titanic.data1$class == "1st class" & titanic.data1$survived == "yes", ]
nFirst <- titanic.data1[titanic.data1$class != "1st class", ]
first - firstSurv
# Vector Recycling = repeat shorter vector to complete math (may not use all the same amount)
vec.a <- c(3,8,4)
vec.b <- c(4,11,7,14)
vec.c <- c(5,9)
vec.a+vec.c
# If multiple, then all elements of shorter vector are used m times
vec.b+vec.c
# length() returns the number of columns
length(vec.b)
# str() returns the data structure description
str(vec.b)
# FACTOR COMMAND
# Used to convert characters into numerical
vec.char <- c("bad","neutral","good")
typeof(vec.char)
fac <- factor(vec.char)
typeof(fac)
# Each level represents an integer, ordered from vec.char alphabetically
levels(fac)
# Integers show the level each elements belongs to
str(fac)
# You can set your own levels (remove alphabetical dependency)
order_fac <- factor(vec.char, levels=vec.char)
str(order_fac)
a <- c(3, 3.1, 3.14, pi, -pi, cos(pi))
y<-matrix(1:20, nrow=5,ncol=4)
w <- list(name="Fred", mynumbers=a, mymatrix=y, age=5.3)
w
# You can access elements by component name or index
w[[1]]
w[["name"]]
w$name
# You can access elements by index, component name, or subsettnig by name
w[[2]]
w[["mynumbers"]]
w$mynumbers
m1 <- matrix(1:20, nrow=5, ncol=4)
m1
# another example
cells <- c(1,26,24,68)
rnames <- c("R1", "R2")
cnames <- c("C1", "C2")
m2 <- matrix(cells, nrow=2, ncol=2, byrow=TRUE, dimnames=list(rnames, cnames))
m2
# To subset matrix, use comma to separate row and column index of a matrix
# all rows and 2nd column of matrix
m2[,2]
# 1st row and all columns of matrix
m2[1,]
# row 2 of columns 1,2
m2[2, c(1,2)]
# To subset matrix, use comma to separate row and column index of a matrix
# Element in 2nd row and 2nd column
m2[2, 2]
y1 <- matrix(1:20, nrows=5)
y2 <- matrix(1:10, nrow=5, ncol=2)
# should have the same number of rows
y_col <- cbind(y1, y2)
y_col
# Binding Matrices
# cbind() - binds matrices by adding columns; requires same number of rows
# rbind() - binds matrices by adding rows; requires same number of columns
y1 <- matrix(1:20, nrow=5)
# should have the same number of rows
y_col <- cbind(y1, y2)
y_col
y3 <- matrix(data = 21:32,nrow = 3,ncol = 4)
## should have the same number of columns
y_rb <- rbind(y1, y3)
y_rb
d <- c(1,2,3,4)
e <- c("red", "white", "red", NA)
f <- c(TRUE,TRUE,TRUE,FALSE)
df <- data.frame(d,e,f)
df
names(df) <- c("ID","Color","Passed")
df
f[c(1, 3), ]
df[, c("ID","Passed")]
