T <- t(P)
dim(T)
dim(P)
Girth = c(8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0)
Height = c(70, 65, 63, 72, 81, 83, 66)
Volume = c(10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6)
my.trees = data.frame(Girth, Height, Volume)
View(my.trees)
# Part 2: Extract the fifth observational unit.
my.trees[5,]
# Part 3: Extract the `Girth` column referring to it by name.
my.trees["Girth"]
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[c(1:(length(my.trees)-1)),]
length(my.trees)
nrow(my.trees)
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[c(1:(nrow(my.trees)-1)),]
# Part A: Check the structure of the`iris` data.
str(iris)
# Part C: Which variables are `numeric` type?
df[is.numeric(df)]
# Part C: Which variables are `numeric` type?
is.numeric(df)
# Part C: Which variables are `numeric` type?
is.numeric(iris)
# Part C: Which variables are `numeric` type?
typeof(iris)
# Part C: Which variables are `numeric` type?
is.numeric(iris[:])
# Part C: Which variables are `numeric` type?
is.numeric(iris[ , ])
# Part C: Which variables are `numeric` type?
is.numeric(iris[c(1:5), ])
# Part 4: Print out a data frame of all the observations except for the last observation.
my.trees[1:(nrow(my.trees)-1),]
# Part C: Which variables are `numeric` type?
is.numeric(iris[1:5, ])
# Part A: Check the structure of the`iris` data.
str(iris)
# Part C: Which variables are `numeric` type?
is.numeric(names(iris))
names(iris)
# Part C: Which variables are `numeric` type?
is.numeric(iris$names(iris))
# Part C: Which variables are `numeric` type?
is.numeric(iris[, 1])
# Part C: Which variables are `numeric` type?
is.numeric(iris[1:5, 1])
is.numeric?
# Part C: Which variables are `numeric` type?
is.numeric(iris[1, ])
# Part C: Which variables are `numeric` type?
is.numeric(iris$Sepal.Length)
# Part A: Check the structure of the`iris` data.
str(iris)
# Part D: Display the first 4 rows of the data.
iris[1:4,]
str(my.trees)
# Part A: Read Titanic data directly from the web: <https://goo.gl/NHb1Pg>
titanic.data1 <- read.csv("https://goo.gl/NHb1Pg", header = TRUE)
d
# Part B: Read this data by saving it first into your working directory.
#         Check your working directory using `getwd()` or change its location using the steps covered in the lesson.
wd <- getwd()
titanic.data2 <- read.csv(paste(wd,"/Titanic_Data.csv"), header = TRUE)
titanic.data2 <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/Titanic_Data.csv", header = TRUE)
# Part C: How many passengers and what variables are in the data set?
str(titanic.data1)
# Part D: Display the first 5 rows of the data.
titanic.data1[1:5, ]
titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes"]
titanic.data1[titanic.data1$class != "1st class"]
titanic.data1[titanic.data1$class != "1st class", ]
titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes", ]
surv <- titanic.data1[titanic.data1$class != "1st class" & titanic.data1$survived == "yes", ]
titanic.data1[titanic.data1$class == "1st class", ]
first <- titanic.data1[titanic.data1$class == "1st class", ]
first <- titanic.data1[titanic.data1$class == "1st class" & titanic.data1$survived == "yes", ]
first <- titanic.data1[titanic.data1$class == "1st class", ]
firstSurv <- titanic.data1[titanic.data1$class == "1st class" & titanic.data1$survived == "yes", ]
nFirst <- titanic.data1[titanic.data1$class != "1st class", ]
first - firstSurv
# Vector Recycling = repeat shorter vector to complete math (may not use all the same amount)
vec.a <- c(3,8,4)
vec.b <- c(4,11,7,14)
vec.c <- c(5,9)
vec.a+vec.c
# If multiple, then all elements of shorter vector are used m times
vec.b+vec.c
# length() returns the number of columns
length(vec.b)
# str() returns the data structure description
str(vec.b)
# FACTOR COMMAND
# Used to convert characters into numerical
vec.char <- c("bad","neutral","good")
typeof(vec.char)
fac <- factor(vec.char)
typeof(fac)
# Each level represents an integer, ordered from vec.char alphabetically
levels(fac)
# Integers show the level each elements belongs to
str(fac)
# You can set your own levels (remove alphabetical dependency)
order_fac <- factor(vec.char, levels=vec.char)
str(order_fac)
a <- c(3, 3.1, 3.14, pi, -pi, cos(pi))
y<-matrix(1:20, nrow=5,ncol=4)
w <- list(name="Fred", mynumbers=a, mymatrix=y, age=5.3)
w
# You can access elements by component name or index
w[[1]]
w[["name"]]
w$name
# You can access elements by index, component name, or subsettnig by name
w[[2]]
w[["mynumbers"]]
w$mynumbers
m1 <- matrix(1:20, nrow=5, ncol=4)
m1
# another example
cells <- c(1,26,24,68)
rnames <- c("R1", "R2")
cnames <- c("C1", "C2")
m2 <- matrix(cells, nrow=2, ncol=2, byrow=TRUE, dimnames=list(rnames, cnames))
m2
# To subset matrix, use comma to separate row and column index of a matrix
# all rows and 2nd column of matrix
m2[,2]
# 1st row and all columns of matrix
m2[1,]
# row 2 of columns 1,2
m2[2, c(1,2)]
# To subset matrix, use comma to separate row and column index of a matrix
# Element in 2nd row and 2nd column
m2[2, 2]
y1 <- matrix(1:20, nrows=5)
y2 <- matrix(1:10, nrow=5, ncol=2)
# should have the same number of rows
y_col <- cbind(y1, y2)
y_col
# Binding Matrices
# cbind() - binds matrices by adding columns; requires same number of rows
# rbind() - binds matrices by adding rows; requires same number of columns
y1 <- matrix(1:20, nrow=5)
# should have the same number of rows
y_col <- cbind(y1, y2)
y_col
y3 <- matrix(data = 21:32,nrow = 3,ncol = 4)
## should have the same number of columns
y_rb <- rbind(y1, y3)
y_rb
d <- c(1,2,3,4)
e <- c("red", "white", "red", NA)
f <- c(TRUE,TRUE,TRUE,FALSE)
df <- data.frame(d,e,f)
df
names(df) <- c("ID","Color","Passed")
df
f[c(1, 3), ]
df[, c("ID","Passed")]
# DESCRIPTIVE STATISTICS
ls()
# DESCRIPTIVE STATISTICS
ls()
Species <- c("Red maple","Aspen","Hackberry","Lodgepole pine","Swamp white oak","Black cherry","Eastern white pine")
Girth <- c(8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0)
Height <- c(70, 65, 63, 72, 81, 83, 66)
Volume <- c(10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6)
mytrees <- data.frame(Species,Girth,Height,Volume)
str(mytrees)
# summary() gives a statistical summary of your dataset
summary(mytrees)
ls(mytrees)
max(x)                    # displays NA
x <- c(2,3,5,NA,7)
max(x)                    # displays NA
max(x, na.rm = TRUE)      # na.rm means remove NA
max(x, na.rm = TRUE)      # na.rm means remove NA
min(x, na.rm = FALSE)     # shows minimum value in a vector
length(x)                 # gives length of the vector and includes na values
sum(x, na.rm = FALSE)     # shows the sum of the vector elements
mean(x, na.rm = FALSE)    # gives an arithmetic mean with this
median( x, na.rm = FALSE) # shows the median value of the vector
sd(x, na.rm = FALSE)      # shows the standard deviation
var(x, na.rm = FALSE)     # shows the variance
mad(x, na.rm = FALSE)     # shows the median absolute deviation
max(x)                    # displays NA
max(x, na.rm = TRUE)      # na.rm means remove NA
min(x, na.rm = TRUE)      # shows minimum value in a vector
length(x)                 # gives length of the vector and includes na values
sum(x, na.rm = TRUE)      # shows the sum of the vector elements
mean(x, na.rm = TRUE)     # gives an arithmetic mean with this
median( x, na.rm = TRUE)  # shows the median value of the vector
sd(x, na.rm = TRUE)       # shows the standard deviation
var(x, na.rm = TRUE)      # shows the variance
mad(x, na.rm = TRUE)      # shows the median absolute deviation
# Multivalue output functions
log(x)                    # shows log value for each element
log(x, na.rm = TRUE)      # does not work with na.rm - causes error
summary(x)                # shows a summary of dataset like maximum value, minimum value, mean, etc.
quantile(x)               # shows the quantiles by default—the 0%, 25%, 50%, 75%, and 100% quantiles
quantile(x, na.rm = TRUE) # shows the quantiles by default—the 0%, 25%, 50%, 75%, and 100% quantiles
# Cumulative commands produce an accurate result when applied to a vector of numeric data
# if applied on character data, they give error populated as a list of NA items
# the cumulative command will work till first NA and thereafter give all result as NA
cumsum(x)                     # the cumulative sum of a vector
cummax(x)                     # the cumulative maximum value
cumin(x)                      # the cumulative minimum value
cummin(x)                      # the cumulative minimum value
cumprod(x)                    # the cumulative product
cumsum(mytrees$Species)       # generates error since character values
cumsum(mytrees$Girth)
sum(mytrees$Girth)
data.frame
# Descriptive statistics for NUMERIC Data Frames
numtrees <- data.frame(Girth,Height,Volume)
max(numtrees$Girth)         # returns the largest value in the data frame
min(numtrees$Girth)         # returns the smallest value in the  data frame
sum(numtrees$Girth)         # returns the sum of the  data frame
fivenum(numtrees$Girth)     # returns the Tukey summary values for the  data frame
length(numtrees$Girth)      # returns the number of columns in the data frame
summary(numtrees$Girth)     # returns the summary for each column
rowmeans(numtrees$Girth)    # returns the summary for each column
rowsums(numtrees$Girth)     # returns the summary for each column
colmeans(numtrees$Girth)    # returns the summary for each column
colsums(numtrees$Girth)     # returns the summary for each column
rowMeans(numtrees$Girth)    # returns the summary for each column
max(numtrees)         # returns the largest value in the data frame
min(numtrees)         # returns the smallest value in the  data frame
sum(numtrees)         # returns the sum of the  data frame
fivenum(numtrees$Girth)     # returns the Tukey summary values for the  data frame
length(numtrees)      # returns the number of columns in the data frame
summary(numtrees)     # returns the summary for each column
rowMeans(numtrees)    # returns the summary for each column
rowSums(numtrees)     # returns the summary for each column
colMeans(numtrees)    # returns the summary for each column
colSums(numtrees)     # returns the summary for each column
# apply(X, MARGIN, FUN, ...)
#    x specifies the matrix or data frame
#    MARGIN command uses either 1 or 2, where 1 is for rows and 2 is for columns
#    replace the FUN part with your command (the function you want to apply)
apply(numtrees, 2, mean)
apply(numtrees, 1, sum)
# Plot histogram
delay <- read.csv("data/flight_delay.csv", header = TRUE) # load the data
hist(delay$Rate.per.10K.Flights)
#    Stem
stem(delay$Rate.per.10K.Flights)
boxplot(chickwts$weight ~ chickwts$feed)
#    Stem
stem(chickwts$weight)
# Double variable plots
#    Scatter plot
plot(delay$Delay, delay$Rate.per.10K.Flights)
#    Box plot
boxplot(chickwts$weight ~ chickwts$feed)
#    Bar plot
barplot(table(chickwts$feed))
# Multivariable plots
set.seed(525354)                       # Set seed for reproducibility
N <- 1000                              # Sample size of 1000
x1 <- rnorm(N)                         # Create variable
x2 <- x1 + rnorm(N, 0, 3)              # Create correlated variable
x3 <- 2 * x1 - x2 + rnorm(N, 0, 2)     # Create another correlated variable
data <- data.frame(x1, x2, x3)         # Combine all variables to data.frame
pairs(data)                            # Apply pairs function
# Part A: Check the structure of the data using the function `str(iris)`.
str(iris)
# Part B: Find the average (or mean) measurement of the variable `Sepal.Length`.
mean(iris$Sepal.Length, na.rm = TRUE)
# Part C: Find the average `Sepal.Length` for the different flower `Species`.
tapply(iris$Sepal.Length, iris$Species, mean)
# Part D: Repeat (1.B) and (1.C) but use the summary standard deviation `sd()`
#         which describes the spread of the variable.
sd(iris$Sepal.Length, na.rm = TRUE)
# Part E: Describe the shape of the variable `Sepal.Length` by creating a
#         histogram using `histogram()`.
tapply(iris$Sepal.Length, iris$Species, sd)
# Part B: Find the average (or mean) measurement of the variable `Sepal.Length`.
slMean <- mean(iris$Sepal.Length, na.rm = TRUE)
# Part C: Find the average `Sepal.Length` for the different flower `Species`.
slMeanBySp <- tapply(iris$Sepal.Length, iris$Species, mean)
# Part D: Repeat (1.B) and (1.C) but use the summary standard deviation `sd()`
#         which describes the spread of the variable.
slSd <- sd(iris$Sepal.Length, na.rm = TRUE)
slSdBySp <- tapply(iris$Sepal.Length, iris$Species, sd)
# Part E: Describe the shape of the variable `Sepal.Length` by creating a
#         histogram using `histogram()`.
hist(iris$Sepal.Length)
# Part F: Compare the `Sepal.Length` of the three species of flowers by creating
#         a side-by-side boxplot using `boxplot()`.
boxplot(slMeanBySp)
# Part F: Compare the `Sepal.Length` of the three species of flowers by creating
#         a side-by-side boxplot using `boxplot()`.
boxplot(slMeanBySp ~ iris$Species)
# Part F: Compare the `Sepal.Length` of the three species of flowers by creating
#         a side-by-side boxplot using `boxplot()`.
boxplot(slMeanBySp ~ iris$Species)
iris$Species
# Part F: Compare the `Sepal.Length` of the three species of flowers by creating
#         a side-by-side boxplot using `boxplot()`.
boxplot(iris$Sepal.Length ~ iris$Species)
# Part C: Find the average `Sepal.Length` for the different flower `Species`.
tapply(iris$Sepal.Length, iris$Species, mean)
tapply(iris$Sepal.Length, iris$Species, sd)
# Part E: Describe the shape of the variable `Sepal.Length` by creating a
#         histogram using `histogram()`.
hist(iris$Sepal.Length)
# Part B: Find the average (or mean) measurement of the variable `Sepal.Length`.
mean(iris$Sepal.Length, na.rm = TRUE)
# Part E: Describe the shape of the variable `Sepal.Length` by creating a
#         histogram using `histogram()`.
hist(iris$Sepal.Length)
# Part F: Compare the `Sepal.Length` of the three species of flowers by creating
#         a side-by-side boxplot using `boxplot()`.
boxplot(iris$Sepal.Length ~ iris$Species)
# Part A: Find the average measurement for the following variables:
#         `BatAge`, `RPG`, `R`, `H` and `BA`
mean(mlb16.data$BatAge, na.rm = TRUE)
# Load the data set `MLB-TeamBatting-S16.csv`
mlb16.data <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/mlb16.csv", header = TRUE)
# Load the data set `MLB-TeamBatting-S16.csv`
mlb16.data <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/data/mlb16.csv", header = TRUE)
mlb16
# Load the data set `MLB-TeamBatting-S16.csv`
mlb16.data <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/data/mlb16.csv", header = TRUE)
str(mlb16.data) # check structure
head(mlb16.data)  # show first six rows
# Part A: Find the average measurement for the following variables:
#         `BatAge`, `RPG`, `R`, `H` and `BA`
mean(mlb16.data$BatAge, na.rm = TRUE)
mean(mlb16.data$RPG, na.rm = TRUE)
mean(mlb16.data$R, na.rm = TRUE)
mean(mlb16.data$H, na.rm = TRUE)
mean(mlb16.data$BA, na.rm = TRUE)
# Part B: Create histogram's for each variable in (2.A).
hist(mlb16.data$BatAge)
hist(mlb16.data$RPG)
hist(mlb16.data$R)
hist(mlb16.data$H)
hist(mlb16.data$BA)
# Part D: Find the average and the standard deviation of the variables
#         `RPG`, `H` and `BA` for each league. Use `tapply()`.
tapply(mlb16.data$RPG, mlb16.data$Lg, mean)
tapply(mlb16.data$RPG, mlb16.data$Lg, sd)
tapply(mlb16.data$H, mlb16.data$Lg, mean)
tapply(mlb16.data$H, mlb16.data$Lg, sd)
tapply(mlb16.data$BA, mlb16.data$Lg, mean)
tapply(mlb16.data$BA, mlb16.data$Lg, sd)
# Load the data set `MLB-TeamBatting-S16.csv`
mlb16.data <- read.csv("/Users/rmazorow/Library/CloudStorage/OneDrive-MarquetteUniversity/School Work/MSSC 5931/Intro-to-R-Prog/data/mlb16.csv", header = TRUE)
str(mlb16.data) # check structure
head(mlb16.data)  # show first six rows
# Part A: Find the average measurement for the following variables:
#         `BatAge`, `RPG`, `R`, `H` and `BA`
mean(mlb16.data$BatAge, na.rm = TRUE)
mean(mlb16.data$RPG, na.rm = TRUE)
mean(mlb16.data$R, na.rm = TRUE)
mean(mlb16.data$H, na.rm = TRUE)
mean(mlb16.data$BA, na.rm = TRUE)
# Part B: Create histogram's for each variable in (2.A).
hist(mlb16.data$BatAge)
hist(mlb16.data$RPG)
hist(mlb16.data$R)
hist(mlb16.data$H)
hist(mlb16.data$BA)
# Part D: Find the average and the standard deviation of the variables
#         `RPG`, `H` and `BA` for each league. Use `tapply()`.
tapply(mlb16.data$RPG, mlb16.data$Lg, mean)
tapply(mlb16.data$RPG, mlb16.data$Lg, sd)
tapply(mlb16.data$H, mlb16.data$Lg, mean)
tapply(mlb16.data$H, mlb16.data$Lg, sd)
tapply(mlb16.data$BA, mlb16.data$Lg, mean)
tapply(mlb16.data$BA, mlb16.data$Lg, sd)
# Part B: Create histogram's for each variable in (2.A).
hist(mlb16.data$BatAge)
# Part A: Find the average measurement for the following variables:
#         `BatAge`, `RPG`, `R`, `H` and `BA`
mean(mlb16.data$BatAge, na.rm = TRUE)
hist(mlb16.data$RPG)
mean(mlb16.data$RPG, na.rm = TRUE)
mean(mlb16.data$R, na.rm = TRUE)
hist(mlb16.data$R)
mean(mlb16.data$H, na.rm = TRUE)
hist(mlb16.data$H)
mean(mlb16.data$BA, na.rm = TRUE)
hist(mlb16.data$BA)
tapply(mlb16.data$RPG, mlb16.data$Lg, mean)
tapply(mlb16.data$RPG, mlb16.data$Lg, sd)
tapply(mlb16.data$H, mlb16.data$Lg, mean)
tapply(mlb16.data$H, mlb16.data$Lg, sd)
tapply(mlb16.data$BA, mlb16.data$Lg, mean)
tapply(mlb16.data$BA, mlb16.data$Lg, sd)
# The probability density function for the standard normal distribution
1/sqrt(2*pi) *exp((-(-4:4)^2/2))
# dnorm(x) function returns the density of the standard normal distribution (mean=0, standard deviation=1) at x.
# Should return the same as the above equation
dnorm(-4:4)
# We can change the mean and standard distribution
dnorm(-8:8, mean=1, sd=2)
# You can plot these distrubtions using curve
curve(dnorm(x), xlim=c(-8,8))
# add=TRUE means combine into one graph
curve(dnorm(x, mean=1, sd=2), col="red", add=TRUE)
# pnorm(z) function returns the cumulative probability of the standard normal distribution at Z score z.
# (the area under the standard normal curve to the left of z - shaded blue region)
pnorm(1.65)
curve(pnorm(1.65))
# pnorm(z) function returns the cumulative probability of the standard normal distribution at Z score z.
# (the area under the standard normal curve to the left of z - shaded blue region)
pnorm(1.65)
curve(pnorm(x))
# Multiple ways to find right side since curve is symmetrical (same on the left)
pnorm(-1.65)                    # The probability of getting a Z score smaller than 1.65 is  95%. (left-side tail)
1-pnorm(1.65)
pnorm(1.65,lower.tail=FALSE)
curve(x)
# pnorm(z) function returns the cumulative probability of the standard normal distribution at Z score z.
# (the area under the standard normal curve to the left of z - shaded blue region)
x <- pnorm(1.65)                     # The probability of getting a Z score smaller than 1.65 is  95% (left-side tail)
curve(dpnorm(x))
curve(pnorm(x))
curve(pnorm(x), xlim=c(-8,8))
# pnorm(z) function returns the cumulative probability of the standard normal distribution at Z score z.
# (the area under the standard normal curve to the left of z - shaded blue region)
pnorm(1.65)                     # The probability of getting a Z score smaller than 1.65 is  95% (left-side tail)
curve(pnorm(x), xlim=c(-8,8))
# Multiple ways to find right side since curve is symmetrical (same on the left)
pnorm(-1.65)                    # The probability of getting a Z score greater than 1.65 is  4.9% (right-side tail)
curve(dnorm(x), xlim=c(-8,8))
# The qnorm() function is the inverse of the pnorm() function
# qnorm(y) returns the value x so that pnorm(x)=y.
qnorm(0.95)                     # the Z score corresponding to the 95th percentile
pnorm( qnorm(0.95) )            # To double check
qnorm(-0.05)                    # Can also get right-side tail
-qnorm(0.05)                    # Can also get right-side tail
# Random number generator
rnorm()
# Random number generator
rnorm(-4:4)
# Random number generator
rnorm(0:1)
# Random number generator
rnorm(2)
# Random number generator
rnorm(1)
# DENSITY OF CHI SQUARED
# dchisq() requires at least 2 arguments: the value of x we want to compute the density and the degree of freedom k
dchisq(x,1)
curve(dchisq(x,1),xlim=c(0,15),ylim=c(0,0.6),ylab="Chi Square Density")
curve(dchisq(x,2),col="red",lty=2,add=TRUE)
curve(dchisq(x,3),col="blue",lty=3,add=TRUE)
curve(dchisq(x,5),col="dark green",lty=4,add=TRUE)
curve(dchisq(x,10),col="brown",lty=5,add=TRUE)
legend(12,0.55,c("k=1","k=2","k=3","k=5","k=10"),
col=c("black","red","blue","dark green","brown"),lty=1:5)
# CUMULATIVE PROBABILITY OF CHI SQUARED
# Again, requires two arguments
# Not symmetrical, so cannot just add negative to get right-side tail
pchisq(21.78,10)
pchisq(21.78,10,lower.tail=FALSE)
1-pchisq(21.78,10)
# QUANTILES OF CHI SQUARED
qchisq(0.05,10)
qchisq(0.05,10,lower.tail=FALSE)
# STUDENT'S T DISTRIBUTION
# Generate 105 random numbers following the t distribution with 5 df
Z <- rnorm(1e5)
W <- rchisq(1e5,5)
T <- Z/sqrt(W/5)
# Plot a histogram for the data
hist(T,breaks=100,freq=FALSE)
# DENSITY T DISTRIBUTION
hist(T, breaks=c(min(T), seq(-5,5,length.out=100), max(T)), freq=FALSE, xlim=c(-5,5))
curve(dt(x,5),col="red",add=TRUE)
# Plots the t curves with various degrees of freedom
curve(dt(x,1),xlim=c(-5,5),ylim=c(0,0.4),ylab="Student's t Density")
curve(dt(x,2),col="red",lty=2,add=TRUE)
curve(dt(x,5),col="blue",lty=3,add=TRUE)
curve(dt(x,20),col="dark green",lty=4,add=TRUE)
curve(dnorm(x),col="brown",lty=5,add=TRUE)
legend(2,0.38,c("k=1","k=2","k=5","k=20","normal curve"),
col=c("black","red","blue","dark green","brown"),lty=1:5)
# SIMULATION
# rnorm(n, mean = 0, sd = 1): generates n standard Normal random numbers with mean 0 and standard deviation 1.
# rchisq(n,df): generates n random numbers following the χ2 distribution with df degrees of freedom.
# rt(n,df): generates n random numbers following the t distribution with df degrees of freedom.
# set.seed() ensures reproducibility of the sequence of random numbers
rnorm(10)
rnorm(10)
set.seed(1234)
rnorm(10)
rnorm(10)                     # Same values because seed was used
set.seed(1234)
rnorm(10)
set.seed(1234)
rnorm(10)                     # Same values because seed was used
set.seed(2819237)
x <- rnorm(1e6)
mean(x)
sd(x)
hist(x)
# sample() function draws randomly from a specified set of (scalar) objects allowing you to sample from arbitrary distributions of numbers
set.seed(12345)
sample(1:10, 4)
sample(1:10, 4)
## Doesn't have to be numbers
sample(letters, 5)
## Sample w/replacement
sample(1:10, replace = TRUE)
